# examine residuals
acf(resid(model), 48)
serial.test(model, lags.pt=12, type = "PR.adjusted")
serial.test(model, lags.pt=12, type = "PT.adjusted")
spectrum(X, ..., method = c("pgram", "ar"))
spectrum(X,  method = c("pgram", "ar"))
fit.pr <- predict(model, n.ahead = 12, ci = 0.95)
fanchart(fit.pr)
fit.pr <- predict(model, n.ahead = 48, ci = 0.95)
fanchart(fit.pr)
fit.pr <- predict(model, n.ahead = 96, ci = 0.95)
fanchart(fit.pr)
12
fit.pr <- predict(model, n.ahead = 12, ci = 0.95)
fanchart(fit.pr)
X <- housing_data[, -1]
nobs <- nrow(housing_data)
data_long <- melt(housing_data, id.vars = "date")
ggplot(data_long, aes(x = date, y = value, colour = variable)) +
geom_line(size = 1.25) +  xlab("") + ylab("Units in thousands")
training_data <- housing_data[1:(nrow(housing_data)-1)]
training_data <- housing_data[1:(nobs-1)]
nobs <- nrow(housing_data)
training_data <- housing_data[1:(nobs-12)]
training_data <- housing_data[1:(nobs-12),]
training_data <- housing_data[1:(nobs-12), ]
rm(list = ls())
library(quantmod)
library(ggplot2)
library(reshape2)
library(vars)
theme_set(theme_bw(base_size = 18))
getSymbols(c('HOUST', 'COMPUTSA'), src='FRED')
houscomp <- data.frame(date = as.Date(index(COMPUTSA)), houst = COMPUTSA)
houst <- data.frame(date = as.Date(index(HOUST)), houst = HOUST)
housing_data <- merge(houst, houscomp, by = "date")
nobs <- nrow(housing_data)
data_long <- melt(housing_data, id.vars = "date")
ggplot(data_long, aes(x = date, y = value, colour = variable)) +
geom_line(size = 1.25) +  xlab("") + ylab("Units in thousands")
training_data <- housing_data[1:(nobs-12), ]
X <- housing_data[, -1]
model <- VAR(y = X, p = 4, type = "const")
summary(model)
acf(resid(model), 48)
serial.test(model, lags.pt=12, type = "PT.adjusted")
spectrum(X,  method = c("pgram", "ar"))
fit.pr <- predict(model, n.ahead = 12, ci = 0.95)
fanchart(fit.pr)
# set up environment
rm(list = ls())
library(quantmod)
library(ggplot2)
library(reshape2)
library(vars)
theme_set(theme_bw(base_size = 18))
# pull data from FRED
getSymbols(c('HOUST', 'COMPUTSA'), src='FRED')
houscomp <- data.frame(date = as.Date(index(COMPUTSA)), houst = COMPUTSA)
# format/plot data
houst <- data.frame(date = as.Date(index(HOUST)), houst = HOUST)
housing_data <- merge(houst, houscomp, by = "date")
nobs <- nrow(housing_data)
data_long <- melt(housing_data, id.vars = "date")
ggplot(data_long, aes(x = date, y = value, colour = variable)) +
geom_line(size = 1.25) +  xlab("") + ylab("Units in thousands")
# drop last 12 observations to be the out of sample forecast comparisons
training_data <- housing_data[1:(nobs-12), ]
# run VAR
X <- training_data[, -1]
model <- VAR(y = X, p = 4, type = "const")
summary(model)
# examine residuals
acf(resid(model), 48)
serial.test(model, lags.pt=12, type = "PT.adjusted")
spectrum(X,  method = c("pgram", "ar"))
# make prediction
fit.pr <- predict(model, n.ahead = 12, ci = 0.95)
fanchart(fit.pr)
rm(list = ls())
library(quantmod)
library(ggplot2)
library(reshape2)
library(vars)
theme_set(theme_bw(base_size = 18))
getSymbols(c('HOUST', 'COMPUTSA'), src='FRED')
houscomp <- data.frame(date = as.Date(index(COMPUTSA)), houst = COMPUTSA)
houst <- data.frame(date = as.Date(index(HOUST)), houst = HOUST)
housing_data <- merge(houst, houscomp, by = "date")
nobs <- nrow(housing_data)
data_long <- melt(housing_data, id.vars = "date")
ggplot(data_long, aes(x = date, y = value, colour = variable)) +
geom_line(size = 1.25) +  xlab("") + ylab("Units in thousands")
training_data <- housing_data[1:(nobs-12), ]
X <- training_data[, -1]
model <- VAR(y = X, p = 4, type = "const")
summary(model)
acf(resid(model), 48)
serial.test(model, lags.pt=12, type = "PT.adjusted")
spectrum(X,  method = c("pgram", "ar"))
fit.pr <- predict(model, n.ahead = 12, ci = 0.95)
fanchart(fit.pr)
x_t <- X[[1]]
x_t
i <- z <- complex(real = 0, imaginary = 1)
i
x <- X[[1]]
i <- z <- complex(real = 0, imaginary = 1)
t<- 45
x[t]
get_spec_density <- function(x, w){
Sw <- 0
for(t in 1:length(x)){
Sw <- Sw + exp(-i * w * t) * x[t]
}
}
pi
spec_density <- get_spec_density(x, pi/2)
spec_density
get_spec_density <- function(x, w){
Sw <- 0
for(t in 1:length(x)){
Sw <- Sw + exp(-i * w * t) * x[t]
}
}
spec_density <- get_spec_density(x, pi/2)
spec_density
t <- 6
Sw
exp(-i * w * t)
w = pi/4
exp(-i * w * t)
exp(-i * w * t) * x[t]
length(x)
get_spec_density <- function(x, w){
Sw <- 0
for(t in 1:length(x)){
Sw <- Sw + exp(-i * w * t) * x[t]
}
return(Sw)
}
spec_density <- get_spec_density(x, pi/2)
spec_density
range <- seq(0, 2*pi, by = 0.1)
range
spec_density <- get_spec_density(x, range)
spec_density
plot(range, spec_density)
range <- seq(0.1, 2*pi, by = 0.1)
spec_density <- get_spec_density(x, range)
plot(range, spec_density)
plot(range, spec_density, type = "l")
sqrt(as.complex(-1))
sqrt(-1)
as.complex(-1)
sqrt(as.complex(-1))
rm(list = ls())
library(reshape2)
library(ggplot2)
library(Quandl)
cons_data <- Quandl(c("FRED/PCNDA", "FRED/PCESVA"),
start_date="1929-01-01",
end_date="2008-12-31",
type="raw")
source("functions.R")
colnames(cons_data) <- c("date", "non_durables", "services")
theme_set(theme_bw(base_size = 20))
cons_data$total <- cons_data$non_durables + cons_data$services
nobs <- nrow(cons_data)
growth <- lapply(cons_data[, -1], FUN = pch)
cons_growth_data <- data.frame(date = cons_data$date[2:nobs],
growth  = as.data.frame(growth))
colnames(cons_growth_data) <- colnames(cons_data)
cons_long <- melt(cons_data, id.vars = "date")
p1 <- ggplot(data = cons_long, aes(x = date, y = log(value), colour = variable))+
geom_line(size = 1.25) +  xlab("") +   ylab("Log Consumption") +
geom_vline(xintercept = as.Date("1950-01-01", format = "%Y-%m-%d")) +
xlab("")+
theme(legend.title = element_blank())
growth_long <- melt(cons_growth_data, id.vars = "date")
p2 <- ggplot(data = growth_long, aes(x = date, y = value, colour = variable))+
geom_line(size = 1.25) +  xlab("") +   ylab("Consumption growth") +
geom_vline(xintercept = as.Date("1950-01-01", format = "%Y-%m-%d")) +
xlab("")+
theme(legend.title = element_blank())
g <- gridExtra::arrangeGrob(p1, p2)
ggsave("../Write_up/connsumption_growth.png",g,  width = 10, height = 8)
mean_MP <- 0.018; sd_MP <- 0.036; ac_MD <- -0.14
setwd("~/OneDrive - PennO365/Classes/2019_Spring/FNCE-921 (Empirical Methods in Finance)/Problem Sets/problem_set_2/code")
rm(list = ls())
library(reshape2)
library(ggplot2)
library(Quandl)
source("functions.R")
theme_set(theme_bw(base_size = 20))
cons_data <- Quandl(c("FRED/PCNDA", "FRED/PCESVA"),
start_date="1929-01-01",
end_date="2008-12-31",
type="raw")
colnames(cons_data) <- c("date", "non_durables", "services")
cons_data$total <- cons_data$non_durables + cons_data$services
growth <- lapply(cons_data[, -1], FUN = pch)
nobs <- nrow(cons_data)
cons_growth_data <- data.frame(date = cons_data$date[2:nobs],
growth  = as.data.frame(growth))
colnames(cons_growth_data) <- colnames(cons_data)
cons_long <- melt(cons_data, id.vars = "date")
p1 <- ggplot(data = cons_long, aes(x = date, y = log(value), colour = variable))+
geom_line(size = 1.25) +  xlab("") +   ylab("Log Consumption") +
geom_vline(xintercept = as.Date("1950-01-01", format = "%Y-%m-%d")) +
xlab("")+
theme(legend.title = element_blank())
growth_long <- melt(cons_growth_data, id.vars = "date")
g <- gridExtra::arrangeGrob(p1, p2)
ggsave("../Write_up/connsumption_growth.png",g,  width = 10, height = 8)
p2 <- ggplot(data = growth_long, aes(x = date, y = value, colour = variable))+
geom_line(size = 1.25) +  xlab("") +   ylab("Consumption growth") +
geom_vline(xintercept = as.Date("1950-01-01", format = "%Y-%m-%d")) +
xlab("")+
theme(legend.title = element_blank())
mean_MP <- 0.018; sd_MP <- 0.036; ac_MD <- -0.14
lambda <-
# second, find mu, sigma, and rho for the following samples
sample_a <- cons_growth_data$total
keep_ind <- which(cons_growth_data$date > as.Date("1950-01-01"))
sample_b <- cons_growth_data$total[keep_ind]
mu_a <- mean(sample_a)
sigma_a <- sd(sample_a)
rho_a <- corr()
mu <- mean_MP + 1; sigma <- sd_MP; phi <- 0.43
Pi <- matrix(data = c(phi, 1- phi, 1 - phi,  phi), nrow = 2)
iota <- matrix(data = 1, nrow = 2, ncol = 1)
A <- rbind(diag(2) - Pi, t(iota))
e3 <- matrix(data = c(0, 0, 1), nrow = 3, ncol = 1)
Pi_star <- solve((t(A) %*% A)) %*% t(A) %*% e3
mu
sigma
phi
rho <- -0.14
dist <- Pi[state, ]
state <- 1
dist <- Pi[state, ]
dist
lambda_1 <- mu + sigma; sigma_2 <- mu-sigma
price <- beta * (Pi[state, 1] * lambda_1^(-gamma) + Pi[state, 2] * lambda^(-gamma))
gamma <- 2
price <- beta * (Pi[state, 1] * lambda_1^(-gamma) + Pi[state, 2] * lambda^(-gamma))
price <- beta * (Pi[state, 1] * lambda_1^(-gamma) + Pi[state, 2] * lambda_2^(-gamma))
lambda_1 <- mu + sigma; lambda_2 <- mu - sigma
price <- beta * (Pi[state, 1] * lambda_1^(-gamma) + Pi[state, 2] * lambda_2^(-gamma))
beta
beta <- 0.95
Pi[state, 1]
price <- beta * (Pi[state, 1] * lambda_1^(-gamma) + Pi[state, 2] * lambda_2^(-gamma))
price
get_bond_price <- function(state, mu, sigma, rho, beta, gamma){
# calculate lambdas
lambda_1 <- mu + sigma; lambda_2 <- mu - sigma
# calculate bond price
price <- beta * (Pi[state, 1] * lambda_1^(-gamma) + Pi[state, 2] * lambda_2^(-gamma))
}
get_bond_price <- function(Pi, state, mu, sigma, beta, gamma){
# calculate lambdas
lambda_1 <- mu + sigma; lambda_2 <- mu - sigma
# calculate bond price
price <- beta * (Pi[state, 1] * lambda_1^(-gamma) + Pi[state, 2] * lambda_2^(-gamma))
}
get_bond_price <- function(Pi, state, mu, sigma, beta, gamma){
# calculate lambdas
lambda_1 <- mu + sigma; lambda_2 <- mu - sigma
# calculate bond price
price <- beta * (Pi[state, 1] * lambda_1^(-gamma) + Pi[state, 2] * lambda_2^(-gamma))
return(price)
}
get_bond_price(Pi = Pi, state = 1, mu = mu, sigma = sigma, beta = 0.95, gamma = 2)
get_bond_price(Pi = Pi, state = 2, mu = mu, sigma = sigma, beta = 0.95, gamma = 2)
Pi
1/get_bond_price(Pi = Pi, state = 2, mu = mu, sigma = sigma, beta = 0.95, gamma = 2)
1/get_bond_price(Pi = Pi, state = 2, mu = mu, sigma = sigma, beta = 0.92, gamma = 2)
1/get_bond_price(Pi = Pi, state = 2, mu = mu, sigma = sigma, beta = 0.98, gamma = 2)
1/get_bond_price(Pi = Pi, state = 2, mu = mu, sigma = sigma, beta = 0.99, gamma = 2)
1/get_bond_price(Pi = Pi, state = 2, mu = mu, sigma = sigma, beta = 0.999, gamma = 2)
1/get_bond_price(Pi = Pi, state = 2, mu = mu, sigma = sigma, beta = 0.995, gamma = 2)
get_bond_price(Pi = Pi, state = 2, mu = mu, sigma = sigma, beta = 0.995, gamma = 2)
Pi[state, 1]
Pi[, 1] * lambda_1^(-gamma)
price <- beta * (Pi[, 1] * lambda_1^(-gamma) + Pi[, 2] * lambda_2^(-gamma))
price
get_bond_prices <- function(Pi, mu, sigma, beta, gamma){
# calculate lambdas
lambda_1 <- mu + sigma; lambda_2 <- mu - sigma
# calculate bond prices
prices <- beta * (Pi[, 1] * lambda_1^(-gamma) + Pi[, 2] * lambda_2^(-gamma))
# return a vector of returns. Each element corresponds to the price in that state
return(prices)
}
get_bond_prices <- function(Pi, mu, sigma, beta, gamma){
# calculate lambdas
lambda_1 <- mu + sigma
lambda_2 <- mu - sigma
# calculate bond prices
prices <- beta * (Pi[, 1] * lambda_1^(-gamma) + Pi[, 2] * lambda_2^(-gamma))
# return a vector of returns. Each element corresponds to the price in that state
return(prices)
}
get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.9, gamma = 2)
get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.99, gamma = 2)
1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.99, gamma = 2)
rm(list = ls())
library(reshape2)
library(ggplot2)
library(Quandl)
source("functions.R")
theme_set(theme_bw(base_size = 20))
#===============================================================================
# Load and plot data
#===============================================================================
cons_data <- Quandl(c("FRED/PCNDA", "FRED/PCESVA"),
start_date="1929-01-01",
end_date="2008-12-31",
type="raw")
colnames(cons_data) <- c("date", "non_durables", "services")
cons_data$total <- cons_data$non_durables + cons_data$services
nobs <- nrow(cons_data)
# calculate consumption growth
growth <- lapply(cons_data[, -1], FUN = pch)
cons_growth_data <- data.frame(date = cons_data$date[2:nobs],
growth  = as.data.frame(growth))
colnames(cons_growth_data) <- colnames(cons_data)
# plot consumption
cons_long <- melt(cons_data, id.vars = "date")
p1 <- ggplot(data = cons_long, aes(x = date, y = log(value), colour = variable))+
geom_line(size = 1.25) +  xlab("") +   ylab("Log Consumption") +
geom_vline(xintercept = as.Date("1950-01-01", format = "%Y-%m-%d")) +
xlab("")+
theme(legend.title = element_blank())
# calculate and plot consumption growth
growth_long <- melt(cons_growth_data, id.vars = "date")
p2 <- ggplot(data = growth_long, aes(x = date, y = value, colour = variable))+
geom_line(size = 1.25) +  xlab("") +   ylab("Consumption growth") +
geom_vline(xintercept = as.Date("1950-01-01", format = "%Y-%m-%d")) +
xlab("")+
theme(legend.title = element_blank())
g <- gridExtra::arrangeGrob(p1, p2)
ggsave("../Write_up/connsumption_growth.png",g,  width = 10, height = 8)
#===============================================================================
# Choose numerical values for the model's parameters such that the equilibrium
# growth process matches that of US annual per-capita growth
#===============================================================================
# first use the original Mehra and Prescott numbers
mean_MP <- 0.018; sd_MP <- 0.036; ac_MD <- -0.14
lambda <-
# second, find mu, sigma, and rho for the following samples
sample_a <- cons_growth_data$total
keep_ind <- which(cons_growth_data$date > as.Date("1950-01-01"))
sample_b <- cons_growth_data$total[keep_ind]
mu_a <- mean(sample_a)
sigma_a <- sd(sample_a)
rho_a <- corr()
#===============================================================================
# a) Markov chains
#===============================================================================
# specify parameters and transition matrix
mu <- mean_MP + 1; sigma <- sd_MP; phi <- 0.43
Pi <- matrix(data = c(phi, 1- phi, 1 - phi,  phi), nrow = 2)
# iii. Solve for the unconditional means
iota <- matrix(data = 1, nrow = 2, ncol = 1)
A <- rbind(diag(2) - Pi, t(iota))
e3 <- matrix(data = c(0, 0, 1), nrow = 3, ncol = 1)
Pi_star <- solve((t(A) %*% A)) %*% t(A) %*% e3
#===============================================================================
# b) Term Structure of Interest Rates
#===============================================================================
gamma <- 2
beta <- 0.95
1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.99, gamma = 2)
1-1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.99, gamma = 2)
1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.99, gamma = 2)-1
1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.97, gamma = 2)-1
1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.975, gamma = 2)-1
1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.9775, gamma = 2)-1
1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.975, gamma = 2)-1
ave_price <- mean(get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.975, gamma = 2))
ave_price
ave_price <- mean(1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.975, gamma = 2))
ave_price
ave_return <- mean(1/get_bond_prices(Pi, mu = mu, sigma = sigma, beta = 0.975, gamma = 2))
ave_return <- mean(1/get_bond_prices(Pi, mu , sigma , 0.975, 2))
ave_return
mean(1/get_bond_prices(Pi, mu , sigma , 0.975, 2))-1
candidate_betas <- seq(0.95, 1.00, by = 0.01)
candidate_betas <- seq(0.95, 1.00, by = 0.001)
mean(1/get_bond_prices(Pi, mu , sigma , candidate_betas, 2))-1
get_bond_prices(Pi, mu , sigma , candidate_betas, 2)
for(i in 1:length(candidate_betas)){
get_bond_prices(Pi, mu , sigma , candidate_betas[i], 2)
}
for(i in 1:length(candidate_betas)){
get_bond_prices(Pi, mu , sigma , candidate_betas[i], 2)
}
apply(X = candidate_betas, MARGIN = 1, FUN = get_bond_prices)
sapply(X = candidate_betas, MARGIN = 1, FUN = get_bond_prices)
sapply(X = candidate_betas, FUN = get_bond_prices)
sapply(X = candidate_betas, FUN = get_bond_prices, mu = mu)
sapply(X = candidate_betas,
FUN = get_bond_prices,
mu = mu, sigma = sigma, gamma = 2)
mapply(X = candidate_betas,
FUN = get_bond_prices,
mu = mu, sigma = sigma, gamma = 2)
candidate_betas <- seq(0.95, 1.00, by = 0.001)
prices <- matrix(data = NA, nrow  = length(candidate_betas), ncol = 1)
for(i in 1:length(candidate_betas)){
prices[i, 1] <- mean(get_bond_prices(Pi, mu , sigma , candidate_betas[i], 2))
}
prices
1/prices
1/prices-1
candidate_betas <- seq(0.95, 1.00, by = 0.0001)
prices <- matrix(data = NA, nrow  = length(candidate_betas), ncol = 1)
for(i in 1:length(candidate_betas)){
prices[i, 1] <- mean(get_bond_prices(Pi, mu , sigma , candidate_betas[i], 2))
}
1/prices-1
min(abs((1/prices-1)-0.05)
min(abs((1/prices-1)-0.05))
min(abs((1/prices-1)-0.05))
which.min(abs((1/prices-1)-0.05))
candidate_betas[which.min(abs((1/prices-1)-0.05))]
beta <- candidate_betas[which.min(abs((1/prices-1)-0.05))]
rm(list = ls())
library(reshape2)
library(ggplot2)
library(Quandl)
source("functions.R")
theme_set(theme_bw(base_size = 20))
#===============================================================================
# Load and plot data
#===============================================================================
cons_data <- Quandl(c("FRED/PCNDA", "FRED/PCESVA"),
start_date="1929-01-01",
end_date="2008-12-31",
type="raw")
colnames(cons_data) <- c("date", "non_durables", "services")
cons_data$total <- cons_data$non_durables + cons_data$services
nobs <- nrow(cons_data)
# calculate consumption growth
growth <- lapply(cons_data[, -1], FUN = pch)
cons_growth_data <- data.frame(date = cons_data$date[2:nobs],
growth  = as.data.frame(growth))
colnames(cons_growth_data) <- colnames(cons_data)
# plot consumption
cons_long <- melt(cons_data, id.vars = "date")
p1 <- ggplot(data = cons_long, aes(x = date, y = log(value), colour = variable))+
geom_line(size = 1.25) +  xlab("") +   ylab("Log Consumption") +
geom_vline(xintercept = as.Date("1950-01-01", format = "%Y-%m-%d")) +
xlab("")+
theme(legend.title = element_blank())
# calculate and plot consumption growth
growth_long <- melt(cons_growth_data, id.vars = "date")
p2 <- ggplot(data = growth_long, aes(x = date, y = value, colour = variable))+
geom_line(size = 1.25) +  xlab("") +   ylab("Consumption growth") +
geom_vline(xintercept = as.Date("1950-01-01", format = "%Y-%m-%d")) +
xlab("")+
theme(legend.title = element_blank())
g <- gridExtra::arrangeGrob(p1, p2)
ggsave("../Write_up/connsumption_growth.png",g,  width = 10, height = 8)
#===============================================================================
# Choose numerical values for the model's parameters such that the equilibrium
# growth process matches that of US annual per-capita growth
#===============================================================================
# first use the original Mehra and Prescott numbers
mean_MP <- 0.018; sd_MP <- 0.036; ac_MD <- -0.14
lambda <-
# second, find mu, sigma, and rho for the following samples
sample_a <- cons_growth_data$total
keep_ind <- which(cons_growth_data$date > as.Date("1950-01-01"))
sample_b <- cons_growth_data$total[keep_ind]
mu_a <- mean(sample_a)
sigma_a <- sd(sample_a)
rho_a <- corr()
#===============================================================================
# a) Markov chains
#===============================================================================
# specify parameters and transition matrix
mu <- mean_MP + 1; sigma <- sd_MP; phi <- 0.43
Pi <- matrix(data = c(phi, 1- phi, 1 - phi,  phi), nrow = 2)
# iii. Solve for the unconditional means
iota <- matrix(data = 1, nrow = 2, ncol = 1)
A <- rbind(diag(2) - Pi, t(iota))
e3 <- matrix(data = c(0, 0, 1), nrow = 3, ncol = 1)
Pi_star <- solve((t(A) %*% A)) %*% t(A) %*% e3
#===============================================================================
# b) Term Structure of Interest Rates
#===============================================================================
gamma <- 2
beta <- 0.95
# find beta the gives a real interest rate of 5 percent
candidate_betas <- seq(0.95, 1.00, by = 0.0001)
prices <- matrix(data = NA, nrow  = length(candidate_betas), ncol = 1)
for(i in 1:length(candidate_betas)){
prices[i, 1] <- mean(get_bond_prices(Pi, mu , sigma , candidate_betas[i], 2))
}
beta <- candidate_betas[which.min(abs((1/prices-1)-0.05))]
beta
candidate_betas <- seq(0.95, 1.00, by = 0.00001)
prices <- matrix(data = NA, nrow  = length(candidate_betas), ncol = 1)
for(i in 1:length(candidate_betas)){
prices[i, 1] <- mean(get_bond_prices(Pi, mu , sigma , candidate_betas[i], 2))
}
beta <- candidate_betas[which.min(abs((1/prices-1)-0.05))]
beta
